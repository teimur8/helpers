https://youtu.be/wi3wPzReKZQ
https://medium.com/webbdev/solid-4ffc018077da

Принцип для ооп
SOLID был описан в 2002 году Робертом Мартином.

S: Single Responsibility Principle (Принцип единственной обязанности).
O: Open-Closed Principle (Принцип открытости-закрытости).
L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).
I: Interface Segregation Principle (Принцип разделения интерфейса).
D: Dependency Inversion Principle (Принцип инверсии зависимостей).

1.Single Responsibility Principle (Принцип единственной обязанности).
Все зависит от того, будет ли у нас причина менять этот код. Каждый кусок кода должен иметь только одну причину для изменения. Каждый класс должен решать лишь одну задачу.

Как вариант класс который является связующим звеном
это DCI - Data Context Interaction, все связи мы выносим в отдельные сущности и контролируете их.

2.Open-Closed Principle (Принцип открытости-закрытости).
Принцип для поддержки работы старого когда. Открыты для расширения, закрыты для изменения.Вы пишете код и не возвращаетесь к написанному коду.
Обычно описывают как переделать switch. Когда логику переносим на объект, а в обработчике просто вызываем метод. Тогда обработчик мы не трогаем, а добавляем объекты.

3.Liskov Substitution Principle (Принцип подстановки Барбары Лисков).
Если мы наследуем объект, то он должен вести так же как и его предок. Когда что то принимает объект и вызывает его методы, принимаю наследника объекта, код не должен ломаться. Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.
Когда нарушается это принцип, значить мы выбрали не правильные абстракции

4.Interface Segregation Principle (Принцип разделения интерфейса)
Здесь не про разделение интерфейсов в php. Скорее разделение больших классов и те кто его используют. Разделения функционала, если у одного объект дергается больше 3-4 метода, ту возможно что стоит его разделить на более мелкие объекты. Когда объект большой, то туда будешь постоянно ходить и его менять.
Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют.

5.Dependency Inversion Principle (Принцип инверсии зависимостей).
Когда два объекта сильно связаны, то мы их разделяем. У нас есть принцип разделения (Decoupling), мы его можем реализовать с помощью IoC или DIP. IoC мы можем реализовать с помощью DI. Как в ларке например. Там IoC контейнер и происходит DI в классы или через сам контейнер или app()->make(). В основном нужно для тестирования.
Для DIP нужны интерфейсы.
Объект ждет HTTP класс, но при тесте мы пихаем ему моковый и он его не принимает. У нас уже связь на уровне типов данных. Для того что бы эту связь разрушить и есть DIP.
Объект ждет HTTPInterface, и HTTP класс и моковый имлпементируют его.

- Decoupling разделение
  - Invertion of Control (IoC) инвертировать контроль
    - Dependercy Injection когда происходит иньекцяи в контроллер или метод. В ларке обычно в контроллер.
    - Factory Method
    - Service Locator
  - Dependency Inversion Principle (DIP) инвертировать зависимость
    - Interfaces
